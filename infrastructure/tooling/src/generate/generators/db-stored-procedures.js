const path = require('path');
const { Schema } = require('taskcluster-lib-postgres');
const {writeRepoFile} = require('../../utils');

exports.tasks = [{
  title: 'README Stored Procedures',
  requires: ['db-schema-serializable'],
  provides: ['readme-stored-procedures'],
  run: async (requirements, utils) => {
    const schema = Schema.fromSerializable(requirements['db-schema-serializable']);
    const methods = schema.allMethods().filter(method => !method.deprecated);
    const serviceNames = [...new Set([...methods].map(({ serviceName }) => serviceName).sort())];
    const services = new Map();

    serviceNames.forEach(sn => {
      const serviceMethods = [...methods].reduce((acc, method) => {
        if (method.serviceName !== sn) {
          return acc;
        }

        return acc.concat(method);
      }, []);

      services.set(sn, serviceMethods.sort((a, b) => a.name.localeCompare(b.name)));
    });

    const output = [];
    output.push('# Stored Functions');
    output.push('<!-- AUTOGENERATED CONTENT; DO NOT EDIT -->\n');

    for (let [serviceName, methods] of services.entries()) {
      output.push(` * [${serviceName} functions](#${serviceName})`);
      for (let {name} of methods) {
        output.push(`   * [\`${name}\`](#${name})`);
      }
    }

    output.push('');

    for (let [serviceName, methods] of services.entries()) {
      output.push(`## ${serviceName}\n`);

      for (let {name} of methods) {
        output.push(`* [\`${name}\`](#${name})`);
      }

      output.push('');

      for (let method of methods) {
        output.push(`### ${method.name}\n`);
        output.push(`* *Mode*: ${method.mode}`);
        output.push(`* *Arguments*:`);

        const args = method.args.replace(/\n/g, ' ').trim();
        if (args.length > 0) {
          for (let arg of args.split(', ')) {
            output.push(`  * \`${arg}\``);
          }
        }

        const returns = method.returns.replace(/\n/g, ' ').trim();
        const tableReturns = /table *\((.*)\)/.exec(returns);
        if (tableReturns) {
          output.push(`* *Returns*: \`table\``);
          for (let r of tableReturns[1].split(', ')) {
            output.push(`  * \`${r}\``);
          }
        } else {
          output.push(`* *Returns*: \`${returns}\``);
        }

        output.push('');
        output.push(method.description);
        output.push('');
      }
    }

    await writeRepoFile(path.join('db', 'fns.md'), output.join('\n'));
  },
}];
