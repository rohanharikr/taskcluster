version: 7
description: bugfix for `.._scan` taskcluster-lib-entities methods
methods:
  # This updates the _scan methods to treat 'page' as an offset.  The previous
  # approach (from verison 2) did not work.

  clients_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if clients_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);
        end if;

        if clients_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  roles_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if roles_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);
        end if;

        if roles_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_github_builds_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_github_builds_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);
        end if;

        if taskcluster_github_builds_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_integration_owners_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_integration_owners_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);
        end if;

        if taskcluster_integration_owners_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_checks_to_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_checks_to_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);
        end if;

        if taskcluster_checks_to_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_check_runs_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_check_runs_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);
        end if;

        if taskcluster_check_runs_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  hooks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if hooks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);
        end if;

        if hooks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queues_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queues_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);
        end if;

        if queues_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  last_fire_3_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if last_fire_3_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);
        end if;

        if last_fire_3_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  indexed_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if indexed_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);
        end if;

        if indexed_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  namespaces_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if namespaces_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);
        end if;

        if namespaces_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  denylisted_notification_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: notify
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if denylisted_notification_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);
        end if;

        if denylisted_notification_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  cache_purges_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: purge_cache
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if cache_purges_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);
        end if;

        if cache_purges_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);
        end if;

        if queue_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_artifacts_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_artifacts_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);
        end if;

        if queue_artifacts_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_groups_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_groups_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);
        end if;

        if queue_task_groups_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_group_members_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_group_members_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);
        end if;

        if queue_task_group_members_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_group_active_sets_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_group_active_sets_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);
        end if;

        if queue_task_group_active_sets_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_requirement_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_requirement_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);
        end if;

        if queue_task_requirement_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_dependency_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_dependency_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);
        end if;

        if queue_task_dependency_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_worker_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_worker_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);
        end if;

        if queue_worker_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_worker_type_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_worker_type_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);
        end if;

        if queue_worker_type_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  queue_provisioner_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_provisioner_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);
        end if;

        if queue_provisioner_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  secrets_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: secrets
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if secrets_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);
        end if;

        if secrets_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  authorization_codes_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if authorization_codes_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);
        end if;

        if authorization_codes_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  access_token_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if access_token_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);
        end if;

        if access_token_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  session_storage_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if session_storage_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);
        end if;

        if session_storage_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  github_access_token_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if github_access_token_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);
        end if;

        if github_access_token_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  wmworkers_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworkers_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);
        end if;

        if wmworkers_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  wmworker_pools_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworker_pools_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);
        end if;

        if wmworker_pools_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
  wmworker_pool_errors_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';
        partition_key_var text;
        row_key_var text;
      begin
        if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworker_pool_errors_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);
        end if;

        if wmworker_pool_errors_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            sql := sql || ' offset ' || page;
          end if;
        end if;

        return query execute sql;
      end
