version: 2
description: define all taskcluster-lib-entities tables and functions
migrationScript: |-
  begin
    create table clients_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table clients_entities add primary key (partition_key, row_key);

    create table roles_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table roles_entities add primary key (partition_key, row_key);

    create table taskcluster_github_builds_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_github_builds_entities add primary key (partition_key, row_key);

    create table taskcluster_integration_owners_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_integration_owners_entities add primary key (partition_key, row_key);

    create table taskcluster_checks_to_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_checks_to_tasks_entities add primary key (partition_key, row_key);

    create table taskcluster_check_runs_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table taskcluster_check_runs_entities add primary key (partition_key, row_key);

    create table hooks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table hooks_entities add primary key (partition_key, row_key);

    create table queues_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queues_entities add primary key (partition_key, row_key);

    create table last_fire_3_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table last_fire_3_entities add primary key (partition_key, row_key);

    create table indexed_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table indexed_tasks_entities add primary key (partition_key, row_key);

    create table namespaces_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table namespaces_entities add primary key (partition_key, row_key);

    create table denylisted_notification_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table denylisted_notification_entities add primary key (partition_key, row_key);

    create table cache_purges_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table cache_purges_entities add primary key (partition_key, row_key);

    create table queue_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_tasks_entities add primary key (partition_key, row_key);

    create table queue_artifacts_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_artifacts_entities add primary key (partition_key, row_key);

    create table queue_task_groups_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_groups_entities add primary key (partition_key, row_key);

    create table queue_task_group_members_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_group_members_entities add primary key (partition_key, row_key);

    create table queue_task_group_active_sets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_group_active_sets_entities add primary key (partition_key, row_key);

    create table queue_task_requirement_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_requirement_entities add primary key (partition_key, row_key);

    create table queue_task_dependency_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_task_dependency_entities add primary key (partition_key, row_key);

    create table queue_worker_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_worker_entities add primary key (partition_key, row_key);

    create table queue_worker_type_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_worker_type_entities add primary key (partition_key, row_key);

    create table queue_provisioner_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table queue_provisioner_entities add primary key (partition_key, row_key);

    create table secrets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table secrets_entities add primary key (partition_key, row_key);

    create table authorization_codes_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table authorization_codes_table_entities add primary key (partition_key, row_key);

    create table access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table access_token_table_entities add primary key (partition_key, row_key);

    create table session_storage_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table session_storage_table_entities add primary key (partition_key, row_key);

    create table github_access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table github_access_token_table_entities add primary key (partition_key, row_key);

    create table wmworkers_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wmworkers_entities add primary key (partition_key, row_key);

    create table wmworker_pools_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wmworker_pools_entities add primary key (partition_key, row_key);

    create table wmworker_pool_errors_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());
    alter table wmworker_pool_errors_entities add primary key (partition_key, row_key);

    grant select, insert, update, delete on clients_entities to $db_user_prefix$_auth;
    grant select, insert, update, delete on roles_entities to $db_user_prefix$_auth;

    grant select, insert, update, delete on taskcluster_check_runs_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_checks_to_tasks_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_github_builds_entities to $db_user_prefix$_github;
    grant select, insert, update, delete on taskcluster_integration_owners_entities to $db_user_prefix$_github;

    grant select, insert, update, delete on hooks_entities to $db_user_prefix$_hooks;
    grant select, insert, update, delete on last_fire_3_entities to $db_user_prefix$_hooks;
    grant select, insert, update, delete on queues_entities to $db_user_prefix$_hooks;

    grant select, insert, update, delete on indexed_tasks_entities to $db_user_prefix$_index;
    grant select, insert, update, delete on namespaces_entities to $db_user_prefix$_index;

    grant select, insert, update, delete on denylisted_notification_entities to $db_user_prefix$_notify;

    grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge_cache;

    grant select, insert, update, delete on secrets_entities to $db_user_prefix$_secrets;

    grant select, insert, update, delete on access_token_table_entities to $db_user_prefix$_web_server;
    grant select, insert, update, delete on authorization_codes_table_entities to $db_user_prefix$_web_server;
    grant select, insert, update, delete on github_access_token_table_entities to $db_user_prefix$_web_server;
    grant select, insert, update, delete on session_storage_table_entities to $db_user_prefix$_web_server;

    grant select, insert, update, delete on wmworker_pool_errors_entities to $db_user_prefix$_worker_manager;
    grant select, insert, update, delete on wmworker_pools_entities to $db_user_prefix$_worker_manager;
    grant select, insert, update, delete on wmworkers_entities to $db_user_prefix$_worker_manager;

    grant select, insert, update, delete on queue_tasks_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_artifacts_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_task_groups_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_task_group_members_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_task_group_active_sets_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_task_requirement_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_task_dependency_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_worker_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_worker_type_entities to $db_user_prefix$_queue;
    grant select, insert, update, delete on queue_provisioner_entities to $db_user_prefix$_queue;
  end
downgradeScript: |-
  begin
    revoke select, insert, update, delete on clients_entities from $db_user_prefix$_auth;
    revoke select, insert, update, delete on roles_entities from $db_user_prefix$_auth;

    revoke select, insert, update, delete on taskcluster_check_runs_entities from $db_user_prefix$_github;
    revoke select, insert, update, delete on taskcluster_checks_to_tasks_entities from $db_user_prefix$_github;
    revoke select, insert, update, delete on taskcluster_github_builds_entities from $db_user_prefix$_github;
    revoke select, insert, update, delete on taskcluster_integration_owners_entities from $db_user_prefix$_github;

    revoke select, insert, update, delete on hooks_entities from $db_user_prefix$_hooks;
    revoke select, insert, update, delete on last_fire_3_entities from $db_user_prefix$_hooks;
    revoke select, insert, update, delete on queues_entities from $db_user_prefix$_hooks;

    revoke select, insert, update, delete on indexed_tasks_entities from $db_user_prefix$_index;
    revoke select, insert, update, delete on namespaces_entities from $db_user_prefix$_index;

    revoke select, insert, update, delete on denylisted_notification_entities from $db_user_prefix$_notify;

    revoke select, insert, update, delete on cache_purges_entities from $db_user_prefix$_purge_cache;

    revoke select, insert, update, delete on secrets_entities from $db_user_prefix$_secrets;

    revoke select, insert, update, delete on access_token_table_entities from $db_user_prefix$_web_server;
    revoke select, insert, update, delete on authorization_codes_table_entities from $db_user_prefix$_web_server;
    revoke select, insert, update, delete on github_access_token_table_entities from $db_user_prefix$_web_server;
    revoke select, insert, update, delete on session_storage_table_entities from $db_user_prefix$_web_server;

    revoke select, insert, update, delete on wmworker_pool_errors_entities from $db_user_prefix$_worker_manager;
    revoke select, insert, update, delete on wmworker_pools_entities from $db_user_prefix$_worker_manager;
    revoke select, insert, update, delete on wmworkers_entities from $db_user_prefix$_worker_manager;

    revoke select, insert, update, delete on queue_tasks_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_artifacts_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_task_groups_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_task_group_members_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_task_group_active_sets_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_task_requirement_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_task_dependency_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_worker_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_worker_type_entities from $db_user_prefix$_queue;
    revoke select, insert, update, delete on queue_provisioner_entities from $db_user_prefix$_queue;

    drop table clients_entities;
    drop table roles_entities;
    drop table taskcluster_github_builds_entities;
    drop table taskcluster_integration_owners_entities;
    drop table taskcluster_checks_to_tasks_entities;
    drop table taskcluster_check_runs_entities;
    drop table hooks_entities;
    drop table queues_entities;
    drop table last_fire_3_entities;
    drop table indexed_tasks_entities;
    drop table namespaces_entities;
    drop table denylisted_notification_entities;
    drop table cache_purges_entities;
    drop table queue_tasks_entities;
    drop table queue_artifacts_entities;
    drop table queue_task_groups_entities;
    drop table queue_task_group_members_entities;
    drop table queue_task_group_active_sets_entities;
    drop table queue_task_requirement_entities;
    drop table queue_task_dependency_entities;
    drop table queue_worker_entities;
    drop table queue_worker_type_entities;
    drop table queue_provisioner_entities;
    drop table secrets_entities;
    drop table authorization_codes_table_entities;
    drop table access_token_table_entities;
    drop table session_storage_table_entities;
    drop table github_access_token_table_entities;
    drop table wmworkers_entities;
    drop table wmworker_pools_entities;
    drop table wmworker_pool_errors_entities;
  end
methods:
  clients_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version,
        clients_entities.etag from clients_entities
        where clients_entities.partition_key = clients_entities_load.partition_key and clients_entities.row_key = clients_entities_load.row_key;
      end
  clients_entities_create:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into clients_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, clients_entities_create.version, new_etag)
          where clients_entities.partition_key = clients_entities_create.pk and clients_entities.row_key = clients_entities_create.rk;
        else
          insert into clients_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  clients_entities_remove:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from clients_entities
        where clients_entities.partition_key = clients_entities_remove.partition_key and clients_entities.row_key = clients_entities_remove.row_key
        returning clients_entities.etag;
      end
  clients_entities_modify:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update clients_entities
        set (value, version, etag) = (properties, clients_entities_modify.version, new_etag)
        where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key and clients_entities.etag = clients_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform clients_entities.etag from clients_entities
        where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  clients_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if clients_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);
        end if;

        if clients_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  roles_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version,
        roles_entities.etag from roles_entities
        where roles_entities.partition_key = roles_entities_load.partition_key and roles_entities.row_key = roles_entities_load.row_key;
      end
  roles_entities_create:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into roles_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, roles_entities_create.version, new_etag)
          where roles_entities.partition_key = roles_entities_create.pk and roles_entities.row_key = roles_entities_create.rk;
        else
          insert into roles_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  roles_entities_remove:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from roles_entities
        where roles_entities.partition_key = roles_entities_remove.partition_key and roles_entities.row_key = roles_entities_remove.row_key
        returning roles_entities.etag;
      end
  roles_entities_modify:
    serviceName: auth
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update roles_entities
        set (value, version, etag) = (properties, roles_entities_modify.version, new_etag)
        where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key and roles_entities.etag = roles_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform roles_entities.etag from roles_entities
        where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  roles_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: auth
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if roles_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);
        end if;

        if roles_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_github_builds_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version,
        taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities
        where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_load.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_load.row_key;
      end
  taskcluster_github_builds_entities_create:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, taskcluster_github_builds_entities_create.version, new_etag)
          where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_create.pk and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_create.rk;
        else
          insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  taskcluster_github_builds_entities_remove:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from taskcluster_github_builds_entities
        where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_remove.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_remove.row_key
        returning taskcluster_github_builds_entities.etag;
      end
  taskcluster_github_builds_entities_modify:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update taskcluster_github_builds_entities
        set (value, version, etag) = (properties, taskcluster_github_builds_entities_modify.version, new_etag)
        where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key and taskcluster_github_builds_entities.etag = taskcluster_github_builds_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities
        where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  taskcluster_github_builds_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_github_builds_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);
        end if;

        if taskcluster_github_builds_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_integration_owners_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version,
        taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities
        where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_load.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_load.row_key;
      end
  taskcluster_integration_owners_entities_create:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, taskcluster_integration_owners_entities_create.version, new_etag)
          where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_create.pk and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_create.rk;
        else
          insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  taskcluster_integration_owners_entities_remove:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from taskcluster_integration_owners_entities
        where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_remove.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_remove.row_key
        returning taskcluster_integration_owners_entities.etag;
      end
  taskcluster_integration_owners_entities_modify:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update taskcluster_integration_owners_entities
        set (value, version, etag) = (properties, taskcluster_integration_owners_entities_modify.version, new_etag)
        where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key and taskcluster_integration_owners_entities.etag = taskcluster_integration_owners_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities
        where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  taskcluster_integration_owners_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_integration_owners_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);
        end if;

        if taskcluster_integration_owners_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_checks_to_tasks_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version,
        taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities
        where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_load.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_load.row_key;
      end
  taskcluster_checks_to_tasks_entities_create:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_create.version, new_etag)
          where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_create.pk and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_create.rk;
        else
          insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  taskcluster_checks_to_tasks_entities_remove:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from taskcluster_checks_to_tasks_entities
        where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_remove.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_remove.row_key
        returning taskcluster_checks_to_tasks_entities.etag;
      end
  taskcluster_checks_to_tasks_entities_modify:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update taskcluster_checks_to_tasks_entities
        set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_modify.version, new_etag)
        where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key and taskcluster_checks_to_tasks_entities.etag = taskcluster_checks_to_tasks_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities
        where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  taskcluster_checks_to_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_checks_to_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);
        end if;

        if taskcluster_checks_to_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  taskcluster_check_runs_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version,
        taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities
        where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_load.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_load.row_key;
      end
  taskcluster_check_runs_entities_create:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, taskcluster_check_runs_entities_create.version, new_etag)
          where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_create.pk and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_create.rk;
        else
          insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  taskcluster_check_runs_entities_remove:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from taskcluster_check_runs_entities
        where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_remove.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_remove.row_key
        returning taskcluster_check_runs_entities.etag;
      end
  taskcluster_check_runs_entities_modify:
    serviceName: github
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update taskcluster_check_runs_entities
        set (value, version, etag) = (properties, taskcluster_check_runs_entities_modify.version, new_etag)
        where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key and taskcluster_check_runs_entities.etag = taskcluster_check_runs_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities
        where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  taskcluster_check_runs_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: github
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if taskcluster_check_runs_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);
        end if;

        if taskcluster_check_runs_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  hooks_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version,
        hooks_entities.etag from hooks_entities
        where hooks_entities.partition_key = hooks_entities_load.partition_key and hooks_entities.row_key = hooks_entities_load.row_key;
      end
  hooks_entities_create:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into hooks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, hooks_entities_create.version, new_etag)
          where hooks_entities.partition_key = hooks_entities_create.pk and hooks_entities.row_key = hooks_entities_create.rk;
        else
          insert into hooks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  hooks_entities_remove:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from hooks_entities
        where hooks_entities.partition_key = hooks_entities_remove.partition_key and hooks_entities.row_key = hooks_entities_remove.row_key
        returning hooks_entities.etag;
      end
  hooks_entities_modify:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update hooks_entities
        set (value, version, etag) = (properties, hooks_entities_modify.version, new_etag)
        where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key and hooks_entities.etag = hooks_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform hooks_entities.etag from hooks_entities
        where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  hooks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if hooks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);
        end if;

        if hooks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queues_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version,
        queues_entities.etag from queues_entities
        where queues_entities.partition_key = queues_entities_load.partition_key and queues_entities.row_key = queues_entities_load.row_key;
      end
  queues_entities_create:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queues_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queues_entities_create.version, new_etag)
          where queues_entities.partition_key = queues_entities_create.pk and queues_entities.row_key = queues_entities_create.rk;
        else
          insert into queues_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queues_entities_remove:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queues_entities
        where queues_entities.partition_key = queues_entities_remove.partition_key and queues_entities.row_key = queues_entities_remove.row_key
        returning queues_entities.etag;
      end
  queues_entities_modify:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queues_entities
        set (value, version, etag) = (properties, queues_entities_modify.version, new_etag)
        where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key and queues_entities.etag = queues_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queues_entities.etag from queues_entities
        where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queues_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queues_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);
        end if;

        if queues_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  last_fire_3_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version,
        last_fire_3_entities.etag from last_fire_3_entities
        where last_fire_3_entities.partition_key = last_fire_3_entities_load.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_load.row_key;
      end
  last_fire_3_entities_create:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into last_fire_3_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, last_fire_3_entities_create.version, new_etag)
          where last_fire_3_entities.partition_key = last_fire_3_entities_create.pk and last_fire_3_entities.row_key = last_fire_3_entities_create.rk;
        else
          insert into last_fire_3_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  last_fire_3_entities_remove:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from last_fire_3_entities
        where last_fire_3_entities.partition_key = last_fire_3_entities_remove.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_remove.row_key
        returning last_fire_3_entities.etag;
      end
  last_fire_3_entities_modify:
    serviceName: hooks
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update last_fire_3_entities
        set (value, version, etag) = (properties, last_fire_3_entities_modify.version, new_etag)
        where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key and last_fire_3_entities.etag = last_fire_3_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform last_fire_3_entities.etag from last_fire_3_entities
        where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  last_fire_3_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: hooks
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if last_fire_3_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);
        end if;

        if last_fire_3_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  indexed_tasks_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version,
        indexed_tasks_entities.etag from indexed_tasks_entities
        where indexed_tasks_entities.partition_key = indexed_tasks_entities_load.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_load.row_key;
      end
  indexed_tasks_entities_create:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, indexed_tasks_entities_create.version, new_etag)
          where indexed_tasks_entities.partition_key = indexed_tasks_entities_create.pk and indexed_tasks_entities.row_key = indexed_tasks_entities_create.rk;
        else
          insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  indexed_tasks_entities_remove:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from indexed_tasks_entities
        where indexed_tasks_entities.partition_key = indexed_tasks_entities_remove.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_remove.row_key
        returning indexed_tasks_entities.etag;
      end
  indexed_tasks_entities_modify:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update indexed_tasks_entities
        set (value, version, etag) = (properties, indexed_tasks_entities_modify.version, new_etag)
        where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key and indexed_tasks_entities.etag = indexed_tasks_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform indexed_tasks_entities.etag from indexed_tasks_entities
        where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  indexed_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if indexed_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);
        end if;

        if indexed_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  namespaces_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version,
        namespaces_entities.etag from namespaces_entities
        where namespaces_entities.partition_key = namespaces_entities_load.partition_key and namespaces_entities.row_key = namespaces_entities_load.row_key;
      end
  namespaces_entities_create:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into namespaces_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, namespaces_entities_create.version, new_etag)
          where namespaces_entities.partition_key = namespaces_entities_create.pk and namespaces_entities.row_key = namespaces_entities_create.rk;
        else
          insert into namespaces_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  namespaces_entities_remove:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from namespaces_entities
        where namespaces_entities.partition_key = namespaces_entities_remove.partition_key and namespaces_entities.row_key = namespaces_entities_remove.row_key
        returning namespaces_entities.etag;
      end
  namespaces_entities_modify:
    serviceName: index
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update namespaces_entities
        set (value, version, etag) = (properties, namespaces_entities_modify.version, new_etag)
        where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key and namespaces_entities.etag = namespaces_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform namespaces_entities.etag from namespaces_entities
        where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  namespaces_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: index
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if namespaces_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);
        end if;

        if namespaces_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  denylisted_notification_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: notify
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version,
        denylisted_notification_entities.etag from denylisted_notification_entities
        where denylisted_notification_entities.partition_key = denylisted_notification_entities_load.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_load.row_key;
      end
  denylisted_notification_entities_create:
    serviceName: notify
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, denylisted_notification_entities_create.version, new_etag)
          where denylisted_notification_entities.partition_key = denylisted_notification_entities_create.pk and denylisted_notification_entities.row_key = denylisted_notification_entities_create.rk;
        else
          insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  denylisted_notification_entities_remove:
    serviceName: notify
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from denylisted_notification_entities
        where denylisted_notification_entities.partition_key = denylisted_notification_entities_remove.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_remove.row_key
        returning denylisted_notification_entities.etag;
      end
  denylisted_notification_entities_modify:
    serviceName: notify
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update denylisted_notification_entities
        set (value, version, etag) = (properties, denylisted_notification_entities_modify.version, new_etag)
        where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key and denylisted_notification_entities.etag = denylisted_notification_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform denylisted_notification_entities.etag from denylisted_notification_entities
        where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  denylisted_notification_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: notify
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if denylisted_notification_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);
        end if;

        if denylisted_notification_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  cache_purges_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: purge_cache
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version,
        cache_purges_entities.etag from cache_purges_entities
        where cache_purges_entities.partition_key = cache_purges_entities_load.partition_key and cache_purges_entities.row_key = cache_purges_entities_load.row_key;
      end
  cache_purges_entities_create:
    serviceName: purge_cache
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into cache_purges_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, cache_purges_entities_create.version, new_etag)
          where cache_purges_entities.partition_key = cache_purges_entities_create.pk and cache_purges_entities.row_key = cache_purges_entities_create.rk;
        else
          insert into cache_purges_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  cache_purges_entities_remove:
    serviceName: purge_cache
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from cache_purges_entities
        where cache_purges_entities.partition_key = cache_purges_entities_remove.partition_key and cache_purges_entities.row_key = cache_purges_entities_remove.row_key
        returning cache_purges_entities.etag;
      end
  cache_purges_entities_modify:
    serviceName: purge_cache
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update cache_purges_entities
        set (value, version, etag) = (properties, cache_purges_entities_modify.version, new_etag)
        where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key and cache_purges_entities.etag = cache_purges_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform cache_purges_entities.etag from cache_purges_entities
        where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  cache_purges_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: purge_cache
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if cache_purges_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);
        end if;

        if cache_purges_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_tasks_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version,
        queue_tasks_entities.etag from queue_tasks_entities
        where queue_tasks_entities.partition_key = queue_tasks_entities_load.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_load.row_key;
      end
  queue_tasks_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_tasks_entities_create.version, new_etag)
          where queue_tasks_entities.partition_key = queue_tasks_entities_create.pk and queue_tasks_entities.row_key = queue_tasks_entities_create.rk;
        else
          insert into queue_tasks_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_tasks_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_tasks_entities
        where queue_tasks_entities.partition_key = queue_tasks_entities_remove.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_remove.row_key
        returning queue_tasks_entities.etag;
      end
  queue_tasks_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_tasks_entities
        set (value, version, etag) = (properties, queue_tasks_entities_modify.version, new_etag)
        where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key and queue_tasks_entities.etag = queue_tasks_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_tasks_entities.etag from queue_tasks_entities
        where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_tasks_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_tasks_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);
        end if;

        if queue_tasks_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_artifacts_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version,
        queue_artifacts_entities.etag from queue_artifacts_entities
        where queue_artifacts_entities.partition_key = queue_artifacts_entities_load.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_load.row_key;
      end
  queue_artifacts_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_artifacts_entities_create.version, new_etag)
          where queue_artifacts_entities.partition_key = queue_artifacts_entities_create.pk and queue_artifacts_entities.row_key = queue_artifacts_entities_create.rk;
        else
          insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_artifacts_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_artifacts_entities
        where queue_artifacts_entities.partition_key = queue_artifacts_entities_remove.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_remove.row_key
        returning queue_artifacts_entities.etag;
      end
  queue_artifacts_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_artifacts_entities
        set (value, version, etag) = (properties, queue_artifacts_entities_modify.version, new_etag)
        where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key and queue_artifacts_entities.etag = queue_artifacts_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_artifacts_entities.etag from queue_artifacts_entities
        where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_artifacts_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_artifacts_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);
        end if;

        if queue_artifacts_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_groups_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version,
        queue_task_groups_entities.etag from queue_task_groups_entities
        where queue_task_groups_entities.partition_key = queue_task_groups_entities_load.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_load.row_key;
      end
  queue_task_groups_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_task_groups_entities_create.version, new_etag)
          where queue_task_groups_entities.partition_key = queue_task_groups_entities_create.pk and queue_task_groups_entities.row_key = queue_task_groups_entities_create.rk;
        else
          insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_task_groups_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_task_groups_entities
        where queue_task_groups_entities.partition_key = queue_task_groups_entities_remove.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_remove.row_key
        returning queue_task_groups_entities.etag;
      end
  queue_task_groups_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_task_groups_entities
        set (value, version, etag) = (properties, queue_task_groups_entities_modify.version, new_etag)
        where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key and queue_task_groups_entities.etag = queue_task_groups_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_task_groups_entities.etag from queue_task_groups_entities
        where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_task_groups_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_groups_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);
        end if;

        if queue_task_groups_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_group_members_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version,
        queue_task_group_members_entities.etag from queue_task_group_members_entities
        where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_load.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_load.row_key;
      end
  queue_task_group_members_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_task_group_members_entities_create.version, new_etag)
          where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_create.pk and queue_task_group_members_entities.row_key = queue_task_group_members_entities_create.rk;
        else
          insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_task_group_members_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_task_group_members_entities
        where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_remove.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_remove.row_key
        returning queue_task_group_members_entities.etag;
      end
  queue_task_group_members_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_task_group_members_entities
        set (value, version, etag) = (properties, queue_task_group_members_entities_modify.version, new_etag)
        where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key and queue_task_group_members_entities.etag = queue_task_group_members_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_task_group_members_entities.etag from queue_task_group_members_entities
        where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_task_group_members_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_group_members_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);
        end if;

        if queue_task_group_members_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_group_active_sets_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version,
        queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities
        where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_load.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_load.row_key;
      end
  queue_task_group_active_sets_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_task_group_active_sets_entities_create.version, new_etag)
          where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_create.pk and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_create.rk;
        else
          insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_task_group_active_sets_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_task_group_active_sets_entities
        where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_remove.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_remove.row_key
        returning queue_task_group_active_sets_entities.etag;
      end
  queue_task_group_active_sets_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_task_group_active_sets_entities
        set (value, version, etag) = (properties, queue_task_group_active_sets_entities_modify.version, new_etag)
        where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key and queue_task_group_active_sets_entities.etag = queue_task_group_active_sets_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities
        where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_task_group_active_sets_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_group_active_sets_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);
        end if;

        if queue_task_group_active_sets_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_requirement_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version,
        queue_task_requirement_entities.etag from queue_task_requirement_entities
        where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_load.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_load.row_key;
      end
  queue_task_requirement_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_task_requirement_entities_create.version, new_etag)
          where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_create.pk and queue_task_requirement_entities.row_key = queue_task_requirement_entities_create.rk;
        else
          insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_task_requirement_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_task_requirement_entities
        where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_remove.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_remove.row_key
        returning queue_task_requirement_entities.etag;
      end
  queue_task_requirement_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_task_requirement_entities
        set (value, version, etag) = (properties, queue_task_requirement_entities_modify.version, new_etag)
        where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key and queue_task_requirement_entities.etag = queue_task_requirement_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_task_requirement_entities.etag from queue_task_requirement_entities
        where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_task_requirement_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_requirement_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);
        end if;

        if queue_task_requirement_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_task_dependency_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version,
        queue_task_dependency_entities.etag from queue_task_dependency_entities
        where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_load.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_load.row_key;
      end
  queue_task_dependency_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_task_dependency_entities_create.version, new_etag)
          where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_create.pk and queue_task_dependency_entities.row_key = queue_task_dependency_entities_create.rk;
        else
          insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_task_dependency_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_task_dependency_entities
        where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_remove.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_remove.row_key
        returning queue_task_dependency_entities.etag;
      end
  queue_task_dependency_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_task_dependency_entities
        set (value, version, etag) = (properties, queue_task_dependency_entities_modify.version, new_etag)
        where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key and queue_task_dependency_entities.etag = queue_task_dependency_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_task_dependency_entities.etag from queue_task_dependency_entities
        where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_task_dependency_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_task_dependency_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);
        end if;

        if queue_task_dependency_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_worker_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version,
        queue_worker_entities.etag from queue_worker_entities
        where queue_worker_entities.partition_key = queue_worker_entities_load.partition_key and queue_worker_entities.row_key = queue_worker_entities_load.row_key;
      end
  queue_worker_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_worker_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_worker_entities_create.version, new_etag)
          where queue_worker_entities.partition_key = queue_worker_entities_create.pk and queue_worker_entities.row_key = queue_worker_entities_create.rk;
        else
          insert into queue_worker_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_worker_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_worker_entities
        where queue_worker_entities.partition_key = queue_worker_entities_remove.partition_key and queue_worker_entities.row_key = queue_worker_entities_remove.row_key
        returning queue_worker_entities.etag;
      end
  queue_worker_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_worker_entities
        set (value, version, etag) = (properties, queue_worker_entities_modify.version, new_etag)
        where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key and queue_worker_entities.etag = queue_worker_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_worker_entities.etag from queue_worker_entities
        where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_worker_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_worker_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);
        end if;

        if queue_worker_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_worker_type_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version,
        queue_worker_type_entities.etag from queue_worker_type_entities
        where queue_worker_type_entities.partition_key = queue_worker_type_entities_load.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_load.row_key;
      end
  queue_worker_type_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_worker_type_entities_create.version, new_etag)
          where queue_worker_type_entities.partition_key = queue_worker_type_entities_create.pk and queue_worker_type_entities.row_key = queue_worker_type_entities_create.rk;
        else
          insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_worker_type_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_worker_type_entities
        where queue_worker_type_entities.partition_key = queue_worker_type_entities_remove.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_remove.row_key
        returning queue_worker_type_entities.etag;
      end
  queue_worker_type_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_worker_type_entities
        set (value, version, etag) = (properties, queue_worker_type_entities_modify.version, new_etag)
        where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key and queue_worker_type_entities.etag = queue_worker_type_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_worker_type_entities.etag from queue_worker_type_entities
        where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_worker_type_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_worker_type_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);
        end if;

        if queue_worker_type_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  queue_provisioner_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version,
        queue_provisioner_entities.etag from queue_provisioner_entities
        where queue_provisioner_entities.partition_key = queue_provisioner_entities_load.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_load.row_key;
      end
  queue_provisioner_entities_create:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, queue_provisioner_entities_create.version, new_etag)
          where queue_provisioner_entities.partition_key = queue_provisioner_entities_create.pk and queue_provisioner_entities.row_key = queue_provisioner_entities_create.rk;
        else
          insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  queue_provisioner_entities_remove:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from queue_provisioner_entities
        where queue_provisioner_entities.partition_key = queue_provisioner_entities_remove.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_remove.row_key
        returning queue_provisioner_entities.etag;
      end
  queue_provisioner_entities_modify:
    serviceName: queue
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update queue_provisioner_entities
        set (value, version, etag) = (properties, queue_provisioner_entities_modify.version, new_etag)
        where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key and queue_provisioner_entities.etag = queue_provisioner_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform queue_provisioner_entities.etag from queue_provisioner_entities
        where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  queue_provisioner_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: queue
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if queue_provisioner_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);
        end if;

        if queue_provisioner_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  secrets_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: secrets
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version,
        secrets_entities.etag from secrets_entities
        where secrets_entities.partition_key = secrets_entities_load.partition_key and secrets_entities.row_key = secrets_entities_load.row_key;
      end
  secrets_entities_create:
    serviceName: secrets
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into secrets_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, secrets_entities_create.version, new_etag)
          where secrets_entities.partition_key = secrets_entities_create.pk and secrets_entities.row_key = secrets_entities_create.rk;
        else
          insert into secrets_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  secrets_entities_remove:
    serviceName: secrets
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from secrets_entities
        where secrets_entities.partition_key = secrets_entities_remove.partition_key and secrets_entities.row_key = secrets_entities_remove.row_key
        returning secrets_entities.etag;
      end
  secrets_entities_modify:
    serviceName: secrets
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update secrets_entities
        set (value, version, etag) = (properties, secrets_entities_modify.version, new_etag)
        where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key and secrets_entities.etag = secrets_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform secrets_entities.etag from secrets_entities
        where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  secrets_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: secrets
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if secrets_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);
        end if;

        if secrets_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  authorization_codes_table_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version,
        authorization_codes_table_entities.etag from authorization_codes_table_entities
        where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_load.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_load.row_key;
      end
  authorization_codes_table_entities_create:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, authorization_codes_table_entities_create.version, new_etag)
          where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_create.pk and authorization_codes_table_entities.row_key = authorization_codes_table_entities_create.rk;
        else
          insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  authorization_codes_table_entities_remove:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from authorization_codes_table_entities
        where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_remove.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_remove.row_key
        returning authorization_codes_table_entities.etag;
      end
  authorization_codes_table_entities_modify:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update authorization_codes_table_entities
        set (value, version, etag) = (properties, authorization_codes_table_entities_modify.version, new_etag)
        where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key and authorization_codes_table_entities.etag = authorization_codes_table_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform authorization_codes_table_entities.etag from authorization_codes_table_entities
        where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  authorization_codes_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if authorization_codes_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);
        end if;

        if authorization_codes_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  access_token_table_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version,
        access_token_table_entities.etag from access_token_table_entities
        where access_token_table_entities.partition_key = access_token_table_entities_load.partition_key and access_token_table_entities.row_key = access_token_table_entities_load.row_key;
      end
  access_token_table_entities_create:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into access_token_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, access_token_table_entities_create.version, new_etag)
          where access_token_table_entities.partition_key = access_token_table_entities_create.pk and access_token_table_entities.row_key = access_token_table_entities_create.rk;
        else
          insert into access_token_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  access_token_table_entities_remove:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from access_token_table_entities
        where access_token_table_entities.partition_key = access_token_table_entities_remove.partition_key and access_token_table_entities.row_key = access_token_table_entities_remove.row_key
        returning access_token_table_entities.etag;
      end
  access_token_table_entities_modify:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update access_token_table_entities
        set (value, version, etag) = (properties, access_token_table_entities_modify.version, new_etag)
        where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key and access_token_table_entities.etag = access_token_table_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform access_token_table_entities.etag from access_token_table_entities
        where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  access_token_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if access_token_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);
        end if;

        if access_token_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  session_storage_table_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version,
        session_storage_table_entities.etag from session_storage_table_entities
        where session_storage_table_entities.partition_key = session_storage_table_entities_load.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_load.row_key;
      end
  session_storage_table_entities_create:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into session_storage_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, session_storage_table_entities_create.version, new_etag)
          where session_storage_table_entities.partition_key = session_storage_table_entities_create.pk and session_storage_table_entities.row_key = session_storage_table_entities_create.rk;
        else
          insert into session_storage_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  session_storage_table_entities_remove:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from session_storage_table_entities
        where session_storage_table_entities.partition_key = session_storage_table_entities_remove.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_remove.row_key
        returning session_storage_table_entities.etag;
      end
  session_storage_table_entities_modify:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update session_storage_table_entities
        set (value, version, etag) = (properties, session_storage_table_entities_modify.version, new_etag)
        where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key and session_storage_table_entities.etag = session_storage_table_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform session_storage_table_entities.etag from session_storage_table_entities
        where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  session_storage_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if session_storage_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);
        end if;

        if session_storage_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  github_access_token_table_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version,
        github_access_token_table_entities.etag from github_access_token_table_entities
        where github_access_token_table_entities.partition_key = github_access_token_table_entities_load.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_load.row_key;
      end
  github_access_token_table_entities_create:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, github_access_token_table_entities_create.version, new_etag)
          where github_access_token_table_entities.partition_key = github_access_token_table_entities_create.pk and github_access_token_table_entities.row_key = github_access_token_table_entities_create.rk;
        else
          insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  github_access_token_table_entities_remove:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from github_access_token_table_entities
        where github_access_token_table_entities.partition_key = github_access_token_table_entities_remove.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_remove.row_key
        returning github_access_token_table_entities.etag;
      end
  github_access_token_table_entities_modify:
    serviceName: web_server
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update github_access_token_table_entities
        set (value, version, etag) = (properties, github_access_token_table_entities_modify.version, new_etag)
        where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key and github_access_token_table_entities.etag = github_access_token_table_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform github_access_token_table_entities.etag from github_access_token_table_entities
        where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  github_access_token_table_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: web_server
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if github_access_token_table_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);
        end if;

        if github_access_token_table_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  wmworkers_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version,
        wmworkers_entities.etag from wmworkers_entities
        where wmworkers_entities.partition_key = wmworkers_entities_load.partition_key and wmworkers_entities.row_key = wmworkers_entities_load.row_key;
      end
  wmworkers_entities_create:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into wmworkers_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, wmworkers_entities_create.version, new_etag)
          where wmworkers_entities.partition_key = wmworkers_entities_create.pk and wmworkers_entities.row_key = wmworkers_entities_create.rk;
        else
          insert into wmworkers_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  wmworkers_entities_remove:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from wmworkers_entities
        where wmworkers_entities.partition_key = wmworkers_entities_remove.partition_key and wmworkers_entities.row_key = wmworkers_entities_remove.row_key
        returning wmworkers_entities.etag;
      end
  wmworkers_entities_modify:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update wmworkers_entities
        set (value, version, etag) = (properties, wmworkers_entities_modify.version, new_etag)
        where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key and wmworkers_entities.etag = wmworkers_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform wmworkers_entities.etag from wmworkers_entities
        where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  wmworkers_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworkers_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);
        end if;

        if wmworkers_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  wmworker_pools_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version,
        wmworker_pools_entities.etag from wmworker_pools_entities
        where wmworker_pools_entities.partition_key = wmworker_pools_entities_load.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_load.row_key;
      end
  wmworker_pools_entities_create:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, wmworker_pools_entities_create.version, new_etag)
          where wmworker_pools_entities.partition_key = wmworker_pools_entities_create.pk and wmworker_pools_entities.row_key = wmworker_pools_entities_create.rk;
        else
          insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  wmworker_pools_entities_remove:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from wmworker_pools_entities
        where wmworker_pools_entities.partition_key = wmworker_pools_entities_remove.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_remove.row_key
        returning wmworker_pools_entities.etag;
      end
  wmworker_pools_entities_modify:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update wmworker_pools_entities
        set (value, version, etag) = (properties, wmworker_pools_entities_modify.version, new_etag)
        where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key and wmworker_pools_entities.etag = wmworker_pools_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform wmworker_pools_entities.etag from wmworker_pools_entities
        where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  wmworker_pools_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworker_pools_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);
        end if;

        if wmworker_pools_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
  wmworker_pool_errors_entities_load:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: partition_key text, row_key text
    returns: table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)
    body: |-
      begin
        return query
        select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version,
        wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities
        where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_load.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_load.row_key;
      end
  wmworker_pool_errors_entities_create:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: pk text, rk text, properties jsonb, overwrite boolean, version integer
    returns: uuid
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        if overwrite then
          insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          ) on conflict (partition_key, row_key) do
          update
          set (value, version, etag) = (properties, wmworker_pool_errors_entities_create.version, new_etag)
          where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_create.pk and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_create.rk;
        else
          insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)
          values (
            pk,
            rk,
            properties,
            version,
            new_etag
          );
        end if;
        return new_etag;
      end
  wmworker_pool_errors_entities_remove:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text
    returns: table (etag uuid)
    body: |-
      begin
        return query delete from wmworker_pool_errors_entities
        where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_remove.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_remove.row_key
        returning wmworker_pool_errors_entities.etag;
      end
  wmworker_pool_errors_entities_modify:
    serviceName: worker_manager
    description: See taskcluster-lib-entities
    mode: write
    args: partition_key text, row_key text, properties jsonb, version integer, old_etag uuid
    returns: table (etag uuid)
    body: |-
      declare
        new_etag uuid := public.gen_random_uuid();
      begin
        update wmworker_pool_errors_entities
        set (value, version, etag) = (properties, wmworker_pool_errors_entities_modify.version, new_etag)
        where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key and wmworker_pool_errors_entities.etag = wmworker_pool_errors_entities_modify.old_etag;

        if found then
          return query select new_etag;
          return;
        end if;

        perform wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities
        where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key;

        if found then
          raise exception 'unsuccessful update' using errcode = 'P0004';
        else
          raise exception 'no such row' using errcode = 'P0002';
        end if;
      end
  wmworker_pool_errors_entities_scan:
    description: See taskcluster-lib-entities
    mode: read
    serviceName: worker_manager
    args: pk text, rk text, condition text, size integer, page integer
    returns: table (partition_key text, row_key text, value jsonb, version integer, etag uuid)
    body: |-
      declare
        sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';
        partition_key_var text;
        row_key_var text;
        page_offset integer;
      begin
        if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then
          sql := sql || ' where ';
        end if;

        if wmworker_pool_errors_entities_scan.pk is not null then
          partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);
        end if;

        if wmworker_pool_errors_entities_scan.rk is not null then
          row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);
        end if;

        sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);
        sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';

        if size is not null and size > 0 then
          sql := sql || ' limit ' || size + 1;

          if page is not null and page > 0 then
            page_offset := size * (page - 1);
            sql := sql || ' offset ' || page_offset;
          end if;
        end if;

        return query execute sql;
      end
